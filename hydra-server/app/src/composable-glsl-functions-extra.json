{
  "_noise": {
    "type": "util",
    "glsl": "\n    //\tSimplex 3D Noise\n    //\tby Ian McEwan, Ashima Arts\n    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat _noise(vec3 v){\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 );\n  vec4 p = permute( permute( permute(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n}\n    ",
    "name": "_noise",
    "example": "no example for function",
    "category": "no category for function"
  },
  "noise": {
    "type": "src",
    "inputs": [
      {
        "type": "float",
        "name": "scale",
        "default": 10
      },
      {
        "type": "float",
        "name": "offset",
        "default": 0.1
      }
    ],
    "glsl": "vec4 noise(vec2 st, float scale, float offset){\n      return vec4(vec3(_noise(vec3(st*scale, offset*time))), 1.0);\n    }",
    "example": "// noise interpolating between different scales and offsets\nnoise( ({time}) => Math.sin(time/10)*50 , ({time}) => Math.sin(time/2)/500 )\n    .out(o0)\n\n",
    "category": "Sources",
    "name": "noise"
  },
  "voronoi": {
    "type": "src",
    "inputs": [
      {
        "type": "float",
        "name": "scale",
        "default": 5
      },
      {
        "type": "float",
        "name": "speed",
        "default": 0.3
      },
      {
        "type": "float",
        "name": "blending",
        "default": 0.3
      }
    ],
    "notes": "from https://thebookofshaders.com/edit.php#12/vorono-01.frag, https://www.shadertoy.com/view/ldB3zc",
    "glsl": "vec4 voronoi(vec2 st, float scale, float speed, float blending) {\n      vec3 color = vec3(.0);\n\n   // Scale\n   st *= scale;\n\n   // Tile the space\n   vec2 i_st = floor(st);\n   vec2 f_st = fract(st);\n\n   float m_dist = 10.;  // minimun distance\n   vec2 m_point;        // minimum point\n\n   for (int j=-1; j<=1; j++ ) {\n       for (int i=-1; i<=1; i++ ) {\n           vec2 neighbor = vec2(float(i),float(j));\n           vec2 p = i_st + neighbor;\n           vec2 point = fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n           point = 0.5 + 0.5*sin(time*speed + 6.2831*point);\n           vec2 diff = neighbor + point - f_st;\n           float dist = length(diff);\n\n           if( dist < m_dist ) {\n               m_dist = dist;\n               m_point = point;\n           }\n       }\n   }\n\n   // Assign a color using the closest point position\n   color += dot(m_point,vec2(.3,.6));\n color *= 1.0 - blending*m_dist;\n   return vec4(color, 1.0);\n    }",
    "example": "// default\nvoronoi(5,0.3,0.3).out(o0)\n\n// fireflies\nvoronoi(25,2,10).color(1,1,0).brightness(0.15).out(o0)\n\n",
    "category": "Sources",
    "name": "voronoi"
  },
  "osc": {
    "type": "src",
    "inputs": [
      {
        "name": "frequency",
        "type": "float",
        "default": 60
      },
      {
        "name": "sync",
        "type": "float",
        "default": 0.1
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec4 osc(vec2 _st, float freq, float sync, float offset){\n            vec2 st = _st;\n            float r = sin((st.x-offset/freq+time*sync)*freq)*0.5  + 0.5;\n            float g = sin((st.x+time*sync)*freq)*0.5 + 0.5;\n            float b = sin((st.x+offset/freq+time*sync)*freq)*0.5  + 0.5;\n            return vec4(r, g, b, 1.0);\n          }",
    "example": "// frequency\nosc( [1,10,50,100,250,500].fast(2) ).out(o0)\n\n// frequency 2\nosc( ({time}) => Math.sin(time/10) * 100 ).out(o0)\n\n// sync\nosc( 10, [-10,-1,-0.1,0,0.1,1,10], 0 ).out(o0)\n\n// offset\nosc(10,0.1, ({time}) => Math.sin(time/10) * 100 ).out(o0)\n\n",
    "category": "Sources",
    "name": "osc"
  },
  "shape": {
    "type": "src",
    "inputs": [
      {
        "name": "sides",
        "type": "float",
        "default": 3
      },
      {
        "name": "radius",
        "type": "float",
        "default": 0.3
      },
      {
        "name": "smoothing",
        "type": "float",
        "default": 0.01
      }
    ],
    "glsl": "vec4 shape(vec2 _st, float sides, float radius, float smoothing){\n      vec2 st = _st * 2. - 1.;\n      // Angle and radius from the current pixel\n      float a = atan(st.x,st.y)+3.1416;\n      float r = (2.*3.1416)/sides;\n      float d = cos(floor(.5+a/r)*r-a)*length(st);\n      return vec4(vec3(1.0-smoothstep(radius,radius + smoothing,d)), 1.0);\n    }",
    "example": "// inverting blurry circle\nshape(100,0.01,1).invert(({time})=>Math.sin(time)*2).out(o0)\n\n// a... rainbow ball?\nshape(5,0.5,0.1).repeat(19,19)\n  .mult(osc(10,1,2))\n  .rotate( ({time}) => time%360 )\n  .scrollX(1,-0.25)\n  .mult(shape(15,0.3,0.01)\n        .rotate( ({time}) => time%360 )\n        .scrollX(1,-0.25))\n  .out(o0)\n\n",
    "category": "Sources",
    "name": "shape"
  },
  "gradient": {
    "type": "src",
    "inputs": [
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec4 gradient(vec2 _st, float speed) {\n      return vec4(_st, sin(time*speed), 1.0);\n    }\n    ",
    "example": "// gradient sequence at speeds of 1, 2 & 4\ngradient([1,2,4]).out(o0)\n\n",
    "category": "Sources",
    "name": "gradient"
  },
  "src": {
    "type": "src",
    "inputs": [
      {
        "name": "tex",
        "type": "texture"
      }
    ],
    "glsl": "vec4 src(vec2 _st, sampler2D _tex){\n    //  vec2 uv = gl_FragCoord.xy/vec2(1280., 720.);\n      return texture2D(_tex, fract(_st));\n    }",
    "example": "no example in documentation",
    "category": "Sources",
    "name": "src"
  },
  "solid": {
    "type": "src",
    "inputs": [
      {
        "name": "r",
        "type": "float",
        "default": 0
      },
      {
        "name": "g",
        "type": "float",
        "default": 0
      },
      {
        "name": "b",
        "type": "float",
        "default": 0
      },
      {
        "name": "a",
        "type": "float",
        "default": 1
      }
    ],
    "notes": "",
    "glsl": "vec4 solid(vec2 uv, float _r, float _g, float _b, float _a){\n      return vec4(_r, _g, _b, _a);\n    }",
    "example": "// cycling through red, green and blue\nsolid([1,0,0],[0,1,0],[0,0,1],1).out(o0)\n\n",
    "category": "Sources",
    "name": "solid"
  },
  "rotate": {
    "type": "coord",
    "inputs": [
      {
        "name": "angle",
        "type": "float",
        "default": 10
      },
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 rotate(vec2 st, float _angle, float speed){\n              vec2 xy = st - vec2(0.5);\n              float angle = _angle + speed *time;\n              xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;\n              xy += 0.5;\n              return xy;\n          }",
    "example": "osc(50).rotate( ({time}) => time%360 ).out(o0)\n\nosc(10,1,1)\n    .rotate( ({time}) => time%360, ({time}) => Math.sin(time*0.1)*0.05 )\n    .out(o0)\n\n",
    "category": "Geometry",
    "name": "rotate"
  },
  "scale": {
    "type": "coord",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 1.5
      },
      {
        "name": "xMult",
        "type": "float",
        "default": 1
      },
      {
        "name": "yMult",
        "type": "float",
        "default": 1
      },
      {
        "name": "offsetX",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "offsetY",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec2 scale(vec2 st, float amount, float xMult, float yMult, float offsetX, float offsetY){\n      vec2 xy = st - vec2(offsetX, offsetY);\n      xy*=(1.0/vec2(amount*xMult, amount*yMult));\n      xy+=vec2(offsetX, offsetY);\n      return xy;\n    }\n    ",
    "example": "// default\nshape().scale(1.5,1,1).out()\n\nshape().scale(1.5,[0.25,0.5,0.75,1].fast(0.25),[3,2,1])\n  .invert([0,1].fast(0.25))\n  .kaleid(5)\n  .kaleid(12)\n  .scale( ({time})=>Math.sin(time/5)*0.5 )\n  .rotate(1,1)\n  .out(o0)\n\n",
    "category": "Geometry",
    "name": "scale"
  },
  "pixelate": {
    "type": "coord",
    "inputs": [
      {
        "name": "pixelX",
        "type": "float",
        "default": 20
      },
      {
        "name": "pixelY",
        "type": "float",
        "default": 20
      }
    ],
    "glsl": "vec2 pixelate(vec2 st, float pixelX, float pixelY){\n      vec2 xy = vec2(pixelX, pixelY);\n      return (floor(st * xy) + 0.5)/xy;\n    }",
    "example": "// default\nnoise().pixelate(20,20).out(o0)\n\nnoise()\n  .mult(osc(10,0.25,1))\n  .scrollY(1,0.25)\n  .pixelate([100,40,20,70].fast(0.25))\n  .modulateRotate(src(o0).scale(0.5),0.125)\n  .diff(src(o0).rotate([-0.05,0.05].fast(0.125)))\n  .out(o0)\n\n",
    "category": "Geometry",
    "name": "pixelate"
  },
  "posterize": {
    "type": "color",
    "inputs": [
      {
        "name": "bins",
        "type": "float",
        "default": 3
      },
      {
        "name": "gamma",
        "type": "float",
        "default": 0.6
      }
    ],
    "glsl": "vec4 posterize(vec4 c, float bins, float gamma){\n      vec4 c2 = pow(c, vec4(gamma));\n      c2 *= vec4(bins);\n      c2 = floor(c2);\n      c2/= vec4(bins);\n      c2 = pow(c2, vec4(1.0/gamma));\n      return vec4(c2.xyz, c.a);\n    }",
    "example": "// static gradient posterized, varying bins\ngradient(0).posterize( [1, 5, 15, 30] , 0.5 ).out(o0)\n\n// static gradient posterized, varying gamma\ngradient(0).posterize( 3, [0.1, 0.5, 1.0, 2.0] ).out(o0)\n\n",
    "category": "Color",
    "name": "posterize"
  },
  "shift": {
    "type": "color",
    "inputs": [
      {
        "name": "r",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "g",
        "type": "float",
        "default": 0
      },
      {
        "name": "b",
        "type": "float",
        "default": 0
      },
      {
        "name": "a",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec4 shift(vec4 c, float r, float g, float b, float a){\n      vec4 c2 = vec4(c);\n      c2.r = fract(c2.r + r);\n      c2.g = fract(c2.g + g);\n      c2.b = fract(c2.b + b);\n      c2.a = fract(c2.a + a);\n      return vec4(c2.rgba);\n    }\n    ",
    "example": "\n\n",
    "category": "Color",
    "name": "shift"
  },
  "repeat": {
    "type": "coord",
    "inputs": [
      {
        "name": "repeatX",
        "type": "float",
        "default": 3
      },
      {
        "name": "repeatY",
        "type": "float",
        "default": 3
      },
      {
        "name": "offsetX",
        "type": "float",
        "default": 0
      },
      {
        "name": "offsetY",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 repeat(vec2 _st, float repeatX, float repeatY, float offsetX, float offsetY){\n        vec2 st = _st * vec2(repeatX, repeatY);\n        st.x += step(1., mod(st.y,2.0)) * offsetX;\n        st.y += step(1., mod(st.x,2.0)) * offsetY;\n        return fract(st);\n    }",
    "example": "// default\nshape().repeat(3.0, 3.0, 0.0, 0.0).out()\n\n// dogtooth factory\nshape(1.25,0.5,0.25)\n  .repeat(3, 3)\n  .scale(2)\n  .repeat(5, 5, ({time}) => Math.sin(time), ({time}) => Math.sin(time/2))\n  .out(o0)\n\n",
    "category": "Geometry",
    "name": "repeat"
  },
  "modulateRepeat": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "repeatX",
        "type": "float",
        "default": 3
      },
      {
        "name": "repeatY",
        "type": "float",
        "default": 3
      },
      {
        "name": "offsetX",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "offsetY",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec2 modulateRepeat(vec2 _st, vec4 c1, float repeatX, float repeatY, float offsetX, float offsetY){\n        vec2 st = _st * vec2(repeatX, repeatY);\n        st.x += step(1., mod(st.y,2.0)) + c1.r * offsetX;\n        st.y += step(1., mod(st.x,2.0)) + c1.g * offsetY;\n        return fract(st);\n    }",
    "example": "// default\nshape(4,0.9)\n  .mult(osc(3,0.5,1))\n  .modulateRepeat(osc(10), 3.0, 3.0, 0.5, 0.5)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateRepeat"
  },
  "repeatX": {
    "type": "coord",
    "inputs": [
      {
        "name": "reps",
        "type": "float",
        "default": 3
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 repeatX(vec2 _st, float reps, float offset){\n      vec2 st = _st * vec2(reps, 1.0);\n    //  float f =  mod(_st.y,2.0);\n\n      st.y += step(1., mod(st.x,2.0))* offset;\n      return fract(st);\n    }",
    "example": "// default\nshape().repeatX(3.0, 0.0).out()\n\nosc(5,0,1)\n  .rotate(1.57)\n  .repeatX([1,2,5,10], ({time}) => Math.sin(time))\n  .out()\n\n",
    "category": "Geometry",
    "name": "repeatX"
  },
  "modulateRepeatX": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "reps",
        "type": "float",
        "default": 3
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec2 modulateRepeatX(vec2 _st, vec4 c1, float reps, float offset){\n      vec2 st = _st * vec2(reps, 1.0);\n    //  float f =  mod(_st.y,2.0);\n      st.y += step(1., mod(st.x,2.0)) + c1.r * offset;\n\n      return fract(st);\n    }",
    "example": "// straight lines illusion\nshape(4,0.9)\n  .mult(osc(4,0.25,1))\n  .modulateRepeatX(osc(10), 5.0, ({time}) => Math.sin(time) * 5)\n  .scale(1,0.5,0.05)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateRepeatX"
  },
  "repeatY": {
    "type": "coord",
    "inputs": [
      {
        "name": "reps",
        "type": "float",
        "default": 3
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 repeatY(vec2 _st, float reps, float offset){\n      vec2 st = _st * vec2(1.0, reps);\n    //  float f =  mod(_st.y,2.0);\n      st.x += step(1., mod(st.y,2.0))* offset;\n      return fract(st);\n    }",
    "example": "// default\nshape().repeatY(3.0, 0.0).out()\n\nosc(5,0,1)\n  .repeatY([1,2,5,10], ({time}) => Math.sin(time))\n  .out()\n\n",
    "category": "Geometry",
    "name": "repeatY"
  },
  "modulateRepeatY": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "reps",
        "type": "float",
        "default": 3
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec2 modulateRepeatY(vec2 _st, vec4 c1, float reps, float offset){\n      vec2 st = _st * vec2(reps, 1.0);\n    //  float f =  mod(_st.y,2.0);\n      st.x += step(1., mod(st.y,2.0)) + c1.r * offset;\n      return fract(st);\n    }",
    "example": "// morphing grid\nshape(4,0.9)\n  .mult(osc(4,0.25,1))\n  .modulateRepeatY(osc(10), 5.0, ({time}) => Math.sin(time) * 5)\n  .scale(1,0.5,0.05)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateRepeatY"
  },
  "kaleid": {
    "type": "coord",
    "inputs": [
      {
        "name": "nSides",
        "type": "float",
        "default": 4
      }
    ],
    "glsl": "vec2 kaleid(vec2 st, float nSides){\n      st -= 0.5;\n      float r = length(st);\n      float a = atan(st.y, st.x);\n      float pi = 2.*3.1416;\n      a = mod(a,pi/nSides);\n      a = abs(a-pi/nSides/2.);\n      return r*vec2(cos(a), sin(a));\n    }",
    "example": "osc(25,-0.1,0.5).kaleid(50).out(o0)\n\n",
    "category": "Geometry",
    "name": "kaleid"
  },
  "modulateKaleid": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "nSides",
        "type": "float",
        "default": 4
      }
    ],
    "glsl": "vec2 modulateKaleid(vec2 st, vec4 c1, float nSides){\n      st -= 0.5;\n      float r = length(st);\n      float a = atan(st.y, st.x);\n      float pi = 2.*3.1416;\n      a = mod(a,pi/nSides);\n      a = abs(a-pi/nSides/2.);\n      return (c1.r+r)*vec2(cos(a), sin(a));\n    }",
    "example": "osc(9,-0.1,0.1)\n  .modulateKaleid(osc(11,0.5,0),50)\n  .scale(0.1,0.3)\n  .modulate(noise(5,0.1))\n  .mult(solid(1,1,0.3))\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateKaleid"
  },
  "scrollX": {
    "type": "coord",
    "inputs": [
      {
        "name": "scrollX",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 scrollX(vec2 st, float amount, float speed){\n      st.x += amount + time*speed;\n      return fract(st);\n    }",
    "example": "// default\nosc(10,0,1).scrollX(0.5,0).out()\n\n// x position\nosc(10,0,1).scrollX([0,0.25,0.5,0.75,1].fast(4),0).out()\n\n// scroll speed\ngradient(1).scrollX(0, ({time}) => Math.sin(time*0.05)*0.05 ).out()\n\ngradient(0.125)\n  .scrollX(0, ({time}) => Math.sin(time*0.05)*0.05 )\n  .scrollY(0, ({time}) => Math.sin(time*0.01)*-0.07 )\n  .pixelate([5,2,10],[15,8])\n  .scale(0.15)\n  .modulate(noise(1,0.25))\n  .out()\n\n",
    "category": "Geometry",
    "name": "scrollX"
  },
  "modulateScrollX": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "scrollX",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 modulateScrollX(vec2 st, vec4 c1, float amount, float speed){\n      st.x += c1.r*amount + time*speed;\n      return fract(st);\n    }",
    "example": "// default\nvoronoi(25,0,0)\n  .modulateScrollX(osc(10),0.5,0)\n  .out(o0)\n\n// different scroll and speed\nvoronoi(25,0,0)\n  .modulateScrollX(osc(10),0.5,0.25)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateScrollX"
  },
  "scrollY": {
    "type": "coord",
    "inputs": [
      {
        "name": "scrollY",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 scrollY(vec2 st, float amount, float speed){\n      st.y += amount + time*speed;\n      return fract(st);\n    }",
    "example": "// default\nosc(10,0,1).scrollY(0.5,0).out()\n\n// y position\nosc(10,0,1).scrollY([0,0.25,0.5,0.75,1].fast(4),0).out()\n\n// scroll speed\ngradient(1).scrollY(0, ({time}) => Math.sin(time*0.05)*0.05 ).out()\n\ngradient(0.125)\n  .scrollX(0, ({time}) => Math.sin(time*0.05)*0.05 )\n  .scrollY(0, ({time}) => Math.sin(time*0.01)*-0.07 )\n  .pixelate([5,2,10],[15,8])\n  .scale(0.15)\n  .modulate(noise(1,0.25))\n  .out()\n\n",
    "category": "Geometry",
    "name": "scrollY"
  },
  "modulateScrollY": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "scrollY",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "speed",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 modulateScrollY(vec2 st, vec4 c1, float amount, float speed){\n      st.y += c1.r*amount + time*speed;\n      return fract(st);\n    }",
    "example": "// default\nvoronoi(25,0,0)\n  .modulateScrollY(osc(10),0.5,0)\n  .out(o0)\n\n// different scroll and speed\nvoronoi(25,0,0)\n  .modulateScrollY(osc(10),0.5,0.25)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateScrollY"
  },
  "add": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "amount",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec4 add(vec4 c0, vec4 c1, float amount){\n            return (c0+c1)*amount + c0*(1.0-amount);\n          }",
    "example": "shape().scale(0.5).add(shape(4),[0,0.25,0.5,0.75,1]).out()\n\nosc(9,0.1,1).add(osc(13,0.5,5)).out()\n\n",
    "category": "Operators",
    "name": "add"
  },
  "layer": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      }
    ],
    "glsl": "vec4 layer(vec4 c0, vec4 c1){\n        return vec4(mix(c0.rgb, c1.rgb, c1.a), c0.a+c1.a);\n    }\n    ",
    "example": "solid(1,0,0,1).layer(shape(4).color(0,1,0,({time})=>Math.sin(time*2))).out()\n\n",
    "category": "Operators",
    "name": "layer"
  },
  "blend": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "amount",
        "type": "float",
        "default": 0.5
      }
    ],
    "glsl": "vec4 blend(vec4 c0, vec4 c1, float amount){\n      return c0*(1.0-amount)+c1*amount;\n    }",
    "example": "shape().scale(0.5).blend(shape(4),[0,0.25,0.5,0.75,1]).out()\n\nosc(9,0.1,1).blend(osc(13,0.5,5)).out()\n\n",
    "category": "Operators",
    "name": "blend"
  },
  "mult": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "amount",
        "type": "float",
        "default": 1
      }
    ],
    "glsl": "vec4 mult(vec4 c0, vec4 c1, float amount){\n      return c0*(1.0-amount)+(c0*c1)*amount;\n    }",
    "example": "osc(9,0.1,2).mult(osc(13,0.5,5)).out()\n\n",
    "category": "Operators",
    "name": "mult"
  },
  "diff": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      }
    ],
    "glsl": "vec4 diff(vec4 c0, vec4 c1){\n      return vec4(abs(c0.rgb-c1.rgb), max(c0.a, c1.a));\n    }\n    ",
    "example": "osc(9,0.1,1).diff(osc(13,0.5,5)).out()\n\nosc(1,1,2)\n  .diff(shape(6,1.1,0.01)\n        .scale(({time})=>Math.sin(time)*0.05 + 0.9)\n        .kaleid(15)\n        .rotate(({time})=>time%360))\n  .out()\n\n",
    "category": "Operators",
    "name": "diff"
  },
  "modulate": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "amount",
        "type": "float",
        "default": 0.1
      }
    ],
    "glsl": "vec2 modulate(vec2 st, vec4 c1, float amount){\n          //  return fract(st+(c1.xy-0.5)*amount);\n              return st + c1.xy*amount;\n          }",
    "example": "// chocolate whirlpool\nvoronoi()\n  .color(0.9,0.25,0.15)\n  .rotate(({time})=>(time%360)/2)\n  .modulate(osc(25,0.1,0.5)\n            .kaleid(50)\n            .scale(({time})=>Math.sin(time*1)*0.5+1)\n            .modulate(noise(0.6,0.5)),\n            0.5)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulate"
  },
  "modulateScale": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "multiple",
        "type": "float",
        "default": 1
      },
      {
        "name": "offset",
        "type": "float",
        "default": 1
      }
    ],
    "glsl": "vec2 modulateScale(vec2 st, vec4 c1, float multiple, float offset){\n      vec2 xy = st - vec2(0.5);\n      xy*=(1.0/vec2(offset + multiple*c1.r, offset + multiple*c1.g));\n      xy+=vec2(0.5);\n      return xy;\n    }",
    "example": "// cosmic radiation\ngradient(5).repeat(50,50).kaleid([3,5,7,9].fast(0.5))\n  .modulateScale(osc(4,-0.5,0).kaleid(50).scale(0.5),15,0)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateScale"
  },
  "modulatePixelate": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "multiple",
        "type": "float",
        "default": 10
      },
      {
        "name": "offset",
        "type": "float",
        "default": 3
      }
    ],
    "glsl": "vec2 modulatePixelate(vec2 st, vec4 c1, float multiple, float offset){\n      vec2 xy = vec2(offset + c1.x*multiple, offset + c1.y*multiple);\n      return (floor(st * xy) + 0.5)/xy;\n    }",
    "example": "// what lies beneath\nvoronoi(10,1,5).brightness(()=>Math.random()*0.15)\n  .modulatePixelate(noise(25,0.5),100)\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulatePixelate"
  },
  "modulateRotate": {
    "type": "combineCoord",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "multiple",
        "type": "float",
        "default": 1
      },
      {
        "name": "offset",
        "type": "float",
        "default": 0
      }
    ],
    "glsl": "vec2 modulateRotate(vec2 st, vec4 c1, float multiple, float offset){\n        vec2 xy = st - vec2(0.5);\n        float angle = offset + c1.x * multiple;\n        xy = mat2(cos(angle),-sin(angle), sin(angle),cos(angle))*xy;\n        xy += 0.5;\n        return xy;\n    }",
    "example": "// wormhole\nvoronoi(100,3,5)\n  .modulateRotate(osc(1,0.5,0).kaleid(50).scale(0.5),15,0)\n  .mult(osc(50,-0.1,8).kaleid(9))\n  .out(o0)\n\n",
    "category": "Modulators",
    "name": "modulateRotate"
  },
  "modulateHue": {
    "type": "combineCoord",
    "notes": "changes coordinates based on hue of second input. Based on: https://www.shadertoy.com/view/XtcSWM",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      },
      {
        "name": "amount",
        "type": "float",
        "default": 1
      }
    ],
    "glsl": "vec2 modulateHue(vec2 st, vec4 c1, float amount){\n\n            return st + (vec2(c1.g - c1.r, c1.b - c1.g) * amount * 1.0/resolution);\n          }",
    "example": "\n\n",
    "category": "Modulators",
    "name": "modulateHue"
  },
  "invert": {
    "type": "color",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 1
      }
    ],
    "glsl": "vec4 invert(vec4 c0, float amount){\n      return vec4((1.0-c0.rgb)*amount + c0.rgb*(1.0-amount), c0.a);\n    }",
    "example": "solid(1,1,1).invert([0,1]).out(o0)\n\n",
    "category": "Color",
    "name": "invert"
  },
  "contrast": {
    "type": "color",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 1.6
      }
    ],
    "glsl": "vec4 contrast(vec4 c0, float amount) {\n      vec4 c = (c0-vec4(0.5))*vec4(amount) + vec4(0.5);\n      return vec4(c.rgb, c0.a);\n    }\n    ",
    "example": "// 20Hz oscillator with contrast interpolating between 0.0-5.0\nosc(20).contrast( ({time}) => Math.sin(time) * 5 ).out(o0)\n\n",
    "category": "Color",
    "name": "contrast"
  },
  "brightness": {
    "type": "color",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 0.4
      }
    ],
    "glsl": "vec4 brightness(vec4 c0, float amount){\n      return vec4(c0.rgb + vec3(amount), c0.a);\n    }\n    ",
    "example": "osc(20,0,2)\n  .brightness( ({time}) => Math.sin(time) )\n  .out(o0)\n\n",
    "category": "Color",
    "name": "brightness"
  },
  "luminance": {
    "type": "util",
    "glsl": "float luminance(vec3 rgb){\n      const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n      return dot(rgb, W);\n    }",
    "name": "luminance",
    "example": "no example for function",
    "category": "no category for function"
  },
  "mask": {
    "type": "combine",
    "inputs": [
      {
        "name": "color",
        "type": "vec4"
      }
    ],
    "glsl": "vec4 mask(vec4 c0, vec4 c1){\n      float a = luminance(c1.rgb);\n      return vec4(c0.rgb*a, a);\n    }",
    "example": "// default\ngradient(5).mask(voronoi(),3,0.5).invert([0,1]).out()\n\n// algae pulse\nosc(10,-0.25,1).color(0,0,1).saturate(2).kaleid(50)\n  .mask(noise(25,2).modulateScale(noise(0.25,0.05)))\n  .modulateScale(osc(6,-0.5,2).kaleid(50))\n  .mult(osc(3,-0.25,2).kaleid(50))\n  .scale(0.5,0.5,0.75)\n  .out()\n\n",
    "category": "Operators",
    "name": "mask"
  },
  "luma": {
    "type": "color",
    "inputs": [
      {
        "name": "threshold",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "tolerance",
        "type": "float",
        "default": 0.1
      }
    ],
    "glsl": "vec4 luma(vec4 c0, float threshold, float tolerance){\n      float a = smoothstep(threshold-tolerance, threshold+tolerance, luminance(c0.rgb));\n      return vec4(c0.rgb*a, a);\n    }",
    "example": "// default\nosc(10,0,1).luma(0.5,0.1).out(o0)\n\nosc(10,0,[0,0.5,1,2]).luma([0.1,0.25,0.75,1].fast(0.25),0.1).out(o0)\n\n",
    "category": "Color",
    "name": "luma"
  },
  "thresh": {
    "type": "color",
    "inputs": [
      {
        "name": "threshold",
        "type": "float",
        "default": 0.5
      },
      {
        "name": "tolerance",
        "type": "float",
        "default": 0.04
      }
    ],
    "glsl": "vec4 thresh(vec4 c0, float threshold, float tolerance){\n      return vec4(vec3(smoothstep(threshold-tolerance, threshold+tolerance, luminance(c0.rgb))), c0.a);\n    }",
    "example": "// default\nnoise(3,0.1).thresh(0.5,0.04).out(o0)\n\nnoise(3,0.1)\n  .thresh( ({time})=>Math.sin(time/2) , [0.04,0.25,0.75,1].fast(0.25) )\n  .out(o0)\n\n",
    "category": "Color",
    "name": "thresh"
  },
  "color": {
    "type": "color",
    "inputs": [
      {
        "name": "r",
        "type": "float",
        "default": 1
      },
      {
        "name": "g",
        "type": "float",
        "default": 1
      },
      {
        "name": "b",
        "type": "float",
        "default": 1
      },
      {
        "name": "a",
        "type": "float",
        "default": 1
      }
    ],
    "notes": "https://www.youtube.com/watch?v=FpOEtm9aX0M",
    "glsl": "vec4 color(vec4 c0, float _r, float _g, float _b, float _a){\n      vec4 c = vec4(_r, _g, _b, _a);\n      vec4 pos = step(0.0, c); // detect whether negative\n\n      // if > 0, return r * c0\n      // if < 0 return (1.0-r) * c0\n      return vec4(mix((1.0-c0)*abs(c), c*c0, pos));\n    }",
    "example": "// 20Hz oscillator source\n// color sequence of Red, Green, Blue, White, Black\n// output to buffer o0\nosc(20).color([1,0,0,1,0],[0,1,0,1,0],[0,0,1,1,0]).out(o0)\n\n",
    "category": "Color",
    "name": "color"
  },
  "_rgbToHsv": {
    "type": "util",
    "glsl": "vec3 _rgbToHsv(vec3 c){\n            vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n            vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n            vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n            float d = q.x - min(q.w, q.y);\n            float e = 1.0e-10;\n            return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n        }",
    "name": "_rgbToHsv",
    "example": "no example for function",
    "category": "no category for function"
  },
  "_hsvToRgb": {
    "type": "util",
    "glsl": "vec3 _hsvToRgb(vec3 c){\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }",
    "name": "_hsvToRgb",
    "example": "no example for function",
    "category": "no category for function"
  },
  "saturate": {
    "type": "color",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 2
      }
    ],
    "glsl": "vec4 saturate(vec4 c0, float amount){\n      const vec3 W = vec3(0.2125, 0.7154, 0.0721);\n      vec3 intensity = vec3(dot(c0.rgb, W));\n      return vec4(mix(intensity, c0.rgb, amount), c0.a);\n    }",
    "example": "osc(10,0,1).saturate( ({time}) => Math.sin(time) * 10 ).out()\n\n",
    "category": "Color",
    "name": "saturate"
  },
  "hue": {
    "type": "color",
    "inputs": [
      {
        "name": "hue",
        "type": "float",
        "default": 0.4
      }
    ],
    "glsl": "vec4 hue(vec4 c0, float hue){\n      vec3 c = _rgbToHsv(c0.rgb);\n      c.r += hue;\n    //  c.r = fract(c.r);\n      return vec4(_hsvToRgb(c), c0.a);\n    }",
    "name": "hue",
    "example": "no example for function",
    "category": "no category for function"
  },
  "colorama": {
    "type": "color",
    "inputs": [
      {
        "name": "amount",
        "type": "float",
        "default": 0.005
      }
    ],
    "glsl": "vec4 colorama(vec4 c0, float amount){\n      vec3 c = _rgbToHsv(c0.rgb);\n      c += vec3(amount);\n      c = _hsvToRgb(c);\n      c = fract(c);\n      return vec4(c, c0.a);\n    }",
    "example": "// 20Hz oscillator source\n// color sequence of Red, Green, Blue, White, Black\n// colorama sequence of 0.005, 0.5, 1.0 at 1/8 speed\n// output to buffer o0\nosc(20)\n  .color([1,0,0,1,0],[0,1,0,1,0],[0,0,1,1,0])\n  .colorama([0.005,0.33,0.66,1.0].fast(0.125))\n  .out(o0)\n\n// \nnoise(3,0.1).colorama( ({time}) => Math.sin(time/5) ).out(o0)\n\n",
    "category": "Color",
    "name": "colorama"
  }
}
